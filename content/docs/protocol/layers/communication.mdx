---
title: Communication Layer
description: Simple HTTP communication designed for scale
icon: Network
---

import { Callout } from "fumadocs-ui/components/callout";
import { Mermaid } from "@/components/mdx/mermaid";

The Communication Layer provides simple HTTP-based communication between agents. It's designed for scale with minimal overhead and developer productivity in mind.

## Design Goals

- **HTTP-First**: Use familiar web technologies
- **Efficient Overhead**: Compact message structures
- **Fast Implementation**: Quick communication setup
- **Scale Optimized**: Efficient for concurrent agent operations

## Communication Flow

<Mermaid
  chart={`
flowchart LR
    A[Agent A] -->|HTTP POST /tasks| B[Agent B]
    B -->|HTTP Response| A
    A -->|GET /capabilities| B
    B -->|Capability List| A
`}
/>

## HTTP-Only Communication (Tier 1)

**Three simple endpoints handle everything**:

### 1. Task Submission: `POST /tasks`

```http
POST /tasks HTTP/1.1
Host: agent.example.com
Content-Type: application/json

{
  "from": "hive:agentid:client123",
  "to": "hive:agentid:agent456",
  "type": "task_request",
  "data": {
    "task_id": "task-789",
    "capability": "text-processing",
    "text": "Hello world",
    "operation": "uppercase"
  },
  "sig": "ed25519_signature"
}
```

### 2. Capability Discovery: `GET /capabilities`

```http
GET /capabilities HTTP/1.1
Host: agent.example.com

# Response:
{
  "capabilities": [
    {
      "id": "text-processing",
      "input": { "text": "string", "operation": "string" },
      "output": { "result": "string" }
    }
  ]
}
```

### 3. Health Check: `GET /status`

```http
GET /status HTTP/1.1
Host: agent.example.com

# Response:
{
  "agent_id": "hive:agentid:agent456",
  "status": "online",
  "capabilities": ["text-processing"],
  "uptime": 86400
}
```

## Message Format

All H.I.V.E. messages use this 5-field format:

```json
{
  "from": "hive:agentid:sender123",
  "to": "hive:agentid:receiver456",
  "type": "task_request",
  "data": { "capability": "text-processing", "text": "hello" },
  "sig": "ed25519_signature"
}
```

**Benefits**:

- **Faster parsing** and processing
- **Easy to implement** in any programming language
- **Human readable** for debugging

<Callout type="info">
  See the [Message Formats](/docs/protocol/structure/message-formats) page for
  complete examples and implementation details.
</Callout>

## Security (Essential Only)

**Required Security Measures**:

- **TLS encryption** for all HTTP communications
- **Ed25519 signatures** for message authentication
- **Agent ID validation** to prevent impersonation

**Signature Process**:

1. Create message without `sig` field
2. Generate JSON string of the message
3. Sign with Ed25519 private key
4. Add signature as `sig` field

```javascript
// Simple signature generation
const messageToSign = { from, to, type, data };
const signature = crypto.sign(
  "sha256",
  JSON.stringify(messageToSign),
  privateKey
);
const finalMessage = { ...messageToSign, sig: signature.toString("base64") };
```

## Implementation for Scale

**For large-scale systems**:

- **Connection pooling**: Reuse HTTP connections
- **Keep-alive**: Reduce connection overhead
- **Compression**: Gzip large payloads
- **Caching**: Cache agent public keys
- **Rate limiting**: Prevent abuse

**Simple Implementation Checklist**:

- [ ] HTTP server with `/tasks`, `/capabilities`, `/status` endpoints
- [ ] Ed25519 key generation and signature verification
- [ ] 5-field message parsing and validation
- [ ] Basic error handling and responses
- [ ] TLS configuration

<Callout type="warning">
  **Security**: Always verify message signatures before processing. Use TLS for
  all communications in production.
</Callout>

<Callout type="info">
  **Performance**: For high-throughput scenarios, implement connection pooling
  and message batching to reduce overhead.
</Callout>

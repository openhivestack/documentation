---
title: Transport Layer
description: HTTP-first transport optimized for simplicity and scale
icon: Wifi
---

import { Callout } from "fumadocs-ui/components/callout";

The Transport Layer focuses on HTTP-first communication for maximum simplicity and compatibility. By prioritizing the most common web protocol, we eliminate complexity while ensuring every developer can implement H.I.V.E. agents quickly.

## HTTP-First Approach

**Why HTTP-only for Tier 1**:

- ✅ **Universal support**: Every platform and language supports HTTP
- ✅ **Existing infrastructure**: Leverage load balancers, CDNs, monitoring tools
- ✅ **Simple debugging**: Use familiar tools like curl, Postman, browser dev tools
- ✅ **Fast implementation**: No complex protocol handling needed

## Essential HTTP Endpoints

**Three endpoints handle everything**:

### 1. `POST /tasks` - Task Processing

```http
POST /tasks HTTP/1.1
Host: agent.example.com
Content-Type: application/json

{
  "from": "hive:agentid:client123",
  "to": "hive:agentid:agent456",
  "type": "task_request",
  "data": {
    "task_id": "task-789",
    "capability": "text-processing",
    "text": "hello world",
    "operation": "uppercase"
  },
  "sig": "ed25519_signature"
}
```

**Response:**

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "from": "hive:agentid:agent456",
  "to": "hive:agentid:client123",
  "type": "task_result",
  "data": {
    "task_id": "task-789",
    "status": "completed",
    "result": { "result": "HELLO WORLD" }
  },
  "sig": "ed25519_signature"
}
```

### 2. `GET /capabilities` - Discovery

```http
GET /capabilities HTTP/1.1
Host: agent.example.com

# Response:
{
  "capabilities": [
    {
      "id": "text-processing",
      "input": { "text": "string", "operation": "string" },
      "output": { "result": "string" }
    }
  ]
}
```

### 3. `GET /status` - Health Check

```http
GET /status HTTP/1.1
Host: agent.example.com

# Response:
{
  "agent_id": "hive:agentid:agent456",
  "status": "online",
  "capabilities": ["text-processing"]
}
```

## Optional Enhancements (Tier 2+)

### WebSockets for Real-Time Updates

**When to add**: Need real-time progress updates for long-running tasks

```javascript
// Simple WebSocket addition to Tier 1 agent
const WebSocket = require("ws");
const wss = new WebSocket.Server({ port: 3001 });

wss.on("connection", (ws) => {
  ws.on("message", (data) => {
    const message = JSON.parse(data);
    if (message.type === "task_update") {
      // Broadcast progress to interested clients
      ws.send(
        JSON.stringify({
          type: "task_update",
          data: { task_id: message.task_id, progress: 0.75 },
        })
      );
    }
  });
});
```

### Message Compression (Tier 2+)

**When to add**: High-frequency communication or large payloads

```javascript
// Add gzip compression to Express
app.use(compression());
```

## Transport Security (Essential Only)

### Required: TLS Encryption

```javascript
// Simple HTTPS server setup
const https = require("https");
const fs = require("fs");

const options = {
  key: fs.readFileSync("private-key.pem"),
  cert: fs.readFileSync("certificate.pem"),
};

https.createServer(options, app).listen(3000);
```

### Required: Ed25519 Signatures

All messages must be signed:

```javascript
// Sign outgoing messages
const messageToSign = { from, to, type, data };
const signature = crypto.sign(
  "sha256",
  JSON.stringify(messageToSign),
  privateKey
);
const signedMessage = { ...messageToSign, sig: signature.toString("base64") };

// Verify incoming messages
const isValid = crypto.verify(
  "sha256",
  JSON.stringify(messageWithoutSig),
  senderPublicKey,
  signature
);
```

## Implementation for Scale (Millions of Agents)

### Performance Optimizations

```javascript
// Connection pooling
const agent = new https.Agent({
  keepAlive: true,
  maxSockets: 100,
});

// Message batching for high frequency
const messageBatch = [];
setInterval(() => {
  if (messageBatch.length > 0) {
    sendBatch(messageBatch);
    messageBatch.length = 0;
  }
}, 100); // Batch every 100ms

// Compression for large payloads
app.use(compression({ threshold: 1024 }));
```

### Simple Implementation Checklist

**Tier 1 Requirements**:

- [ ] HTTP server with 3 endpoints
- [ ] TLS configuration
- [ ] Ed25519 signature generation/verification
- [ ] JSON message parsing
- [ ] Basic error handling

**Performance Enhancements**:

- [ ] Connection pooling
- [ ] Keep-alive connections
- [ ] Message compression (>1KB)
- [ ] Request rate limiting
- [ ] Connection timeouts

<Callout type="info">
  **HTTP-First Benefits**: By focusing on HTTP, you can leverage existing
  infrastructure like load balancers, CDNs, and monitoring tools without
  additional complexity.
</Callout>

<Callout type="warning">
  **Security**: Always use TLS in production. HTTP is only acceptable for local
  development and testing.
</Callout>

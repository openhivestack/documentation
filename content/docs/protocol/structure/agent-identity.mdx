---
title: Agent Identity
description: simple agent identification for massive scale
icon: UserCheck
---

import { Callout } from "fumadocs-ui/components/callout";

Agent Identity in the H.I.V.E. Protocol uses the simplest possible approach to uniquely identify agents. 

## Simple Identity (Tier 1)

**Everything you need for agent identity**:

1. **Agent ID**: `agentid:hive:uniqueIdentifier`
2. **Ed25519 Key Pair**: For signing and verification
3. **Endpoint URL**: Where to reach the agent

That's it! No profiles, metadata, or complex resolution needed.

## Agent ID Format

```
agentid:hive:uniqueIdentifier
```

**Examples**:

- `agentid:hive:abc123def456` (random)
- `agentid:hive:translator-service-v1` (descriptive)
- `agentid:hive:company-chatbot-2024` (organizational)

**Requirements**:

- Must start with `agentid:hive:`
- Unique identifier can be any string (alphanumeric + hyphens recommended)
- Maximum length: 64 characters total
- Case sensitive

## Identity Creation (30 seconds)

```javascript
import crypto from "crypto";

// 1. Generate Ed25519 key pair
const { publicKey, privateKey } = crypto.generateKeyPairSync("ed25519", {
  publicKeyEncoding: { type: "spki", format: "pem" },
  privateKeyEncoding: { type: "pkcs8", format: "pem" },
});

// 2. Create unique identifier
const uniqueId = crypto.randomBytes(8).toString("hex");

// 3. Form Agent ID
const agentId = `agentid:hive:${uniqueId}`;

// 4. Save securely (environment variables in production)
process.env.AGENT_ID = agentId;
process.env.AGENT_PRIVATE_KEY = privateKey;
process.env.AGENT_PUBLIC_KEY = publicKey;

console.log(`âœ… Agent Identity Created: ${agentId}`);
```

## Identity Verification

**Process**:

```javascript
// Verify agent identity from message
function verifyAgentIdentity(message) {
  const { from, sig, ...messageWithoutSig } = message;

  // 1. Validate Agent ID format
  if (!from.startsWith("agentid:hive:")) {
    return { valid: false, error: "invalid_agent_id_format" };
  }

  // 2. Get sender's public key (from cache, registry, or direct query)
  const senderPublicKey = getSenderPublicKey(from);
  if (!senderPublicKey) {
    return { valid: false, error: "public_key_not_found" };
  }

  // 3. Verify message signature
  try {
    const isValid = crypto.verify(
      "sha256",
      JSON.stringify(messageWithoutSig),
      senderPublicKey,
      Buffer.from(sig, "base64")
    );

    return { valid: isValid, error: isValid ? null : "invalid_signature" };
  } catch (error) {
    return { valid: false, error: "signature_verification_failed" };
  }
}
```

## Public Key Distribution

**How other agents get your public key**:

### Method 1: Registry Registration (Recommended)

```javascript
// Register with registry
const registration = {
  agent_id: AGENT_ID,
  endpoint: `https://myagent.example.com`,
  public_key: publicKey,
  capabilities: [
    /* capability list */
  ],
};

fetch("https://registry.example.com/agents", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify(registration),
});
```

### Method 2: Direct Query

```javascript
// Provide public key via endpoint
app.get("/identity", (req, res) => {
  res.json({
    agent_id: AGENT_ID,
    public_key: publicKey,
    endpoint: `https://myagent.example.com`,
  });
});
```

### Method 3: Include in Messages (Tier 2+)

```json
{
  "from": "agentid:hive:abc123",
  "to": "agentid:hive:xyz789",
  "type": "task_request",
  "data": {
    /* task data */
  },
  "public_key": "-----BEGIN PUBLIC KEY-----...",
  "sig": "signature"
}
```

## Identity Caching

**For performance at scale**:

```javascript
// Simple public key cache
const publicKeyCache = new Map();
const CACHE_TTL = 3600000; // 1 hour

async function getSenderPublicKey(agentId) {
  // Check cache first
  const cached = publicKeyCache.get(agentId);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.publicKey;
  }

  // Fetch from registry or direct query
  try {
    const response = await fetch(
      `https://registry.example.com/agents/${agentId}`
    );
    const agentInfo = await response.json();

    // Cache the result
    publicKeyCache.set(agentId, {
      publicKey: agentInfo.public_key,
      timestamp: Date.now(),
    });

    return agentInfo.public_key;
  } catch (error) {
    console.error(`Failed to fetch public key for ${agentId}:`, error);
    return null;
  }
}
```

## Implementation Checklist

**Tier 1 Identity Requirements**:

- [ ] Generate Ed25519 key pair
- [ ] Create Agent ID with `agentid:hive:` prefix
- [ ] Store private key securely
- [ ] Implement signature generation and verification
- [ ] Provide public key distribution method
- [ ] Basic Agent ID format validation

**Optional Enhancements (Tier 2+)**:

- [ ] Public key caching for performance
- [ ] Key rotation support
- [ ] Multiple key management
- [ ] Identity metadata
- [ ] Advanced verification methods

<Callout type="info">
  **Simplicity Benefit**: This approach eliminates 90% of identity complexity
  while maintaining security. Most agents never need more than basic identity.
</Callout>

<Callout type="warning">
  **Security Critical**: Protect private keys at all costs. Use environment
  variables, secure key stores, or hardware security modules in production.
</Callout>

<Callout type="info">
  **Performance**: Implement public key caching to avoid repeated lookups. At
  scale, cache hits can improve performance by 10x.
</Callout>

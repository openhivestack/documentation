---
title: Discovery Flow
description: How agents discover each other's capabilities
icon: Search
---

import { Callout } from "fumadocs-ui/components/callout";
import { Mermaid } from "@/components/mdx/mermaid";

The Discovery Flow in the H.I.V.E. Protocol defines how agents find each other and learn about their capabilities.
This standardized process enables dynamic collaboration between previously unconnected agents.

## Discovery Methods

The H.I.V.E. Protocol supports multiple discovery methods to accommodate different deployment scenarios:

<Mermaid
  chart={`
flowchart TD
    A[Agent Discovery] --> B[Registry-Based Discovery]
    A --> C[Direct Discovery]
    A --> D[Broadcast Discovery]
    A --> E[Federation-Based Discovery]
`}
/>

### Registry-Based Discovery

Registry-based discovery is the most common approach, using a central directory service where agents register their
capabilities and can be found by others.

<Mermaid
  chart={`
sequenceDiagram
    participant Agent A
    participant Registry
    participant Agent B

    Agent A->>Registry: Register capabilities
    Registry-->>Agent A: Registration confirmation

    Agent B->>Registry: Query for capabilities
    Registry-->>Agent B: Agent A's details and capabilities

    Agent B->>Agent A: Direct connection
`}
/>

#### Registration Process

1. **Agent Registration**: Agent sends its identity, endpoints, and capabilities to the registry
2. **Verification**: Registry verifies the agent's signature and validates capability format
3. **Storage**: Registry stores the agent's information in its directory
4. **Confirmation**: Registry confirms successful registration to the agent

```http
# Registration Request
POST /registry/agents HTTP/1.1
Host: registry.example.com
Content-Type: application/json

{
  "agentId": "agent-abc123",
  "publicKey": "-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----",
  "endpoints": {
    "http": "https://agent-abc123.example.com/api",
    "websocket": "wss://agent-abc123.example.com/ws"
  },
  "capabilities": [
    {
      "id": "text-translation",
      "version": "1.0",
      "supportedLanguages": ["en", "es", "fr", "de"],
      "maxTextLength": 10000
    }
  ],
  "timestamp": "2025-07-18T12:00:00Z",
  "signature": "Base64-encoded signature"
}
```

```http
# Registration Response
HTTP/1.1 200 OK
Content-Type: application/json

{
  "status": "registered",
  "registryId": "registry.example.com",
  "agentId": "agent-abc123",
  "registrationExpires": "2025-07-19T12:00:00Z"
}
```

#### Discovery Process

1. **Capability Query**: Agent queries the registry for agents with specific capabilities
2. **Filtering**: Registry filters registered agents based on query criteria
3. **Response**: Registry returns matching agents with their endpoints and capabilities
4. **Direct Connection**: The querying agent connects directly to the discovered agent

```http
# Discovery Query
GET /registry/agents?capability=text-translation&language=es HTTP/1.1
Host: registry.example.com
Accept: application/json
```

```http
# Discovery Response
HTTP/1.1 200 OK
Content-Type: application/json

{
  "agents": [
    {
      "agentId": "agent-abc123",
      "publicKey": "-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----",
      "endpoints": {
        "http": "https://agent-abc123.example.com/api",
        "websocket": "wss://agent-abc123.example.com/ws"
      },
      "capabilities": [
        {
          "id": "text-translation",
          "version": "1.0",
          "supportedLanguages": ["en", "es", "fr", "de"],
          "maxTextLength": 10000
        }
      ],
      "lastSeen": "2025-07-18T12:00:00Z"
    },
    // Other matching agents...
  ]
}
```

### Direct Discovery

Direct discovery is used when an agent already knows the endpoint of another agent and wants to learn about its
capabilities.

<Mermaid
  chart={`
sequenceDiagram
    participant Agent A
    participant Agent B

    Agent A->>Agent B: Capability query
    Agent B-->>Agent A: Capability advertisement
`}
/>

#### Direct Query Process

1. **Capability Query**: Agent sends a direct query to the known endpoint
2. **Response**: The queried agent responds with its capabilities
3. **Verification**: The querying agent verifies the response signature

```json
// Direct Capability Query
{
  "messageType": "CAPABILITY_QUERY",
  "payload": {
    "queryType": "ALL"
  }
}
```

```json
// Direct Capability Response
{
  "messageType": "CAPABILITY_ADVERTISEMENT",
  "payload": {
    "capabilities": [
      {
        "id": "text-translation",
        "version": "1.0",
        "supportedLanguages": ["en", "es", "fr", "de"],
        "maxTextLength": 10000
      }
    ]
  }
}
```

### Broadcast Discovery

Broadcast discovery enables agents to announce their presence and capabilities to the network without a central registry.

<Mermaid
  chart={`
sequenceDiagram
    participant Agent A
    participant Network
    participant Agent B
    participant Agent C

    Agent A->>Network: Broadcast capability advertisement
    Network-->>Agent B: Receive advertisement
    Network-->>Agent C: Receive advertisement

    Agent B->>Agent A: Direct connection
`}
/>

#### Broadcast Process

1. **Capability Broadcast**: Agent broadcasts its capabilities to the network
2. **Multicast Receipt**: Other agents on the network receive the broadcast
3. **Filtering**: Receiving agents filter broadcasts based on their needs
4. **Direct Connection**: Interested agents connect directly to the broadcasting agent

```json
// Broadcast Advertisement
{
  "messageType": "CAPABILITY_BROADCAST",
  "payload": {
    "agentId": "agent-abc123",
    "publicKey": "-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----",
    "endpoints": {
      "http": "https://agent-abc123.example.com/api",
      "websocket": "wss://agent-abc123.example.com/ws"
    },
    "capabilities": [
      {
        "id": "text-translation",
        "version": "1.0",
        "supportedLanguages": ["en", "es", "fr", "de"]
      }
    ],
    "broadcastId": "broadcast-123456",
    "timestamp": "2025-07-18T12:00:00Z"
  }
}
```

### Federation-Based Discovery

Federation-based discovery connects multiple registries to provide a broader view of available agents while
maintaining administrative boundaries.

<Mermaid
  chart={`
flowchart TD
    A[Agent A] -->|Register| B[Registry 1]
    C[Agent C] -->|Register| D[Registry 2]

    B <-->|Federation| D

    E[Agent B] -->|Query| B
    B -->|Results include\nAgent A and Agent C| E
`}
/>

#### Federation Process

1. **Registry Federation**: Registries establish federation relationships
2. **Cross-Registry Queries**: Queries to one registry can return results from federated registries
3. **Aggregation**: Results from multiple registries are aggregated before returning to the querying agent

## Discovery Protocols

The H.I.V.E. Protocol supports multiple underlying discovery protocols:

### HTTP-Based Discovery

Using standard HTTP endpoints for registration and discovery:

- `POST /registry/agents` for registration
- `GET /registry/agents` for discovery queries
- `GET /registry/agents/{agentId}` for specific agent lookup

### DNS-Based Discovery

Using DNS records for discovery in decentralized environments:

- SRV records for service discovery
- TXT records for capability advertisements
- NAPTR records for service resolution

### mDNS/DNS-SD

For local network discovery without a central registry:

- Multicast DNS for local name resolution
- DNS Service Discovery for capability advertisement
- Zero-configuration networking

## Discovery Security

The discovery process includes several security measures:

1. **Signature Verification**: All registration and advertisement messages are signed
2. **Timestamp Validation**: Messages include timestamps to prevent replay attacks
3. **Registry Authentication**: Registries authenticate themselves to agents
4. **Capability Validation**: Registries validate capability format before acceptance

<Callout type="warning">
  Always verify signatures on discovery responses to prevent malicious impersonation of agents.
</Callout>

## Registration Maintenance

Registration with discovery services requires ongoing maintenance:

1. **Regular Renewal**: Agents must periodically renew their registration
2. **Heartbeat Signals**: Optional heartbeat signals to indicate continued availability
3. **Capability Updates**: Agents should update their registration when capabilities change
4. **Deregistration**: Agents should deregister when shutting down gracefully

```http
# Registration Renewal
PUT /registry/agents/agent-abc123 HTTP/1.1
Host: registry.example.com
Content-Type: application/json

{
  "agentId": "agent-abc123",
  "timestamp": "2025-07-19T12:00:00Z",
  "signature": "Base64-encoded signature"
}
```

## Discovery Response Caching

To improve efficiency, discovery responses can be cached:

1. **TTL-Based Caching**: Responses include a time-to-live for caching
2. **Conditional Requests**: Use ETags or Last-Modified headers for conditional requests
3. **Capability Versioning**: Capability versions help determine cache invalidation

<Callout type="info">
  Implement proper caching strategies for discovery responses to reduce network load and improve responsiveness.
</Callout>

## Implementation Considerations

When implementing discovery in your agent:

1. **Fallback Mechanisms**: Implement multiple discovery methods with fallback options
2. **Capability Filtering**: Filter discovery results client-side for more precise matching
3. **Rate Limiting**: Respect rate limits of discovery services
4. **Error Handling**: Implement robust error handling for discovery failures
5. **Privacy Considerations**: Be aware of what capabilities reveal about your agent

<Callout type="info">
  For more details on capability descriptions, see the [Capability Advertisement](/docs/protocol/structure/capability-advertisement) documentation.
</Callout>

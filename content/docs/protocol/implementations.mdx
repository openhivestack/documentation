---
title: Implementations
description: simple implementations optimized for rapid development
icon: Package
---

import { Callout } from "fumadocs-ui/components/callout";
import { Cards, Card } from "fumadocs-ui/components/card";

H.I.V.E. Protocol implementations are designed for maximum simplicity and minimum dependencies. No complex SDKs required - just standard HTTP libraries and crypto functions available in every programming language.

## Implementation Philosophy

**No SDK Required**: H.I.V.E. is so simple that you don't need a special SDK. Use your language's standard HTTP and crypto libraries.

**Minimal Dependencies**: Most implementations need only:

- HTTP server library (Express, Flask, etc.)
- JSON parsing (built into most languages)
- Ed25519 crypto library
- TLS support (usually built-in)

## Language Examples

### JavaScript/Node.js

**Dependencies**: `express` only (crypto is built-in)

```javascript
const express = require("express");
const crypto = require("crypto");

const app = express();
app.use(express.json());

const AGENT_ID = "hive:agentid:" + crypto.randomBytes(8).toString("hex");
const { publicKey, privateKey } = crypto.generateKeyPairSync("ed25519");

app.post("/tasks", (req, res) => {
  const { from, data } = req.body;
  const result = { result: data.text.toUpperCase() };
  const response = {
    from: AGENT_ID,
    to: from,
    type: "task_result",
    data: { task_id: data.task_id, result },
  };
  res.json({
    ...response,
    sig: crypto
      .sign(null, Buffer.from(JSON.stringify(response)), privateKey)
      .toString("base64"),
  });
});

app.get("/capabilities", (req, res) =>
  res.json({
    capabilities: [
      {
        id: "text-processing",
        input: { text: "string" },
        output: { result: "string" },
      },
    ],
  })
);
app.listen(3000);
```

### Python/Flask

**Dependencies**: `flask`, `cryptography`

```python
from flask import Flask, request, jsonify
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey
import json
import secrets

app = Flask(__name__)

# Generate agent identity
private_key = Ed25519PrivateKey.generate()
public_key = private_key.public_key()
AGENT_ID = f"hive:agentid:{secrets.token_hex(8)}"

def sign_message(message):
    message_bytes = json.dumps(message, sort_keys=True).encode()
    signature = private_key.sign(message_bytes)
    return signature.hex()

@app.route('/tasks', methods=['POST'])
def handle_task():
    data = request.json
    task_data = data['data']

    # Process task
    result = {"result": task_data['text'].upper()}

    response = {
        "from": AGENT_ID,
        "to": data['from'],
        "type": "task_result",
        "data": {"task_id": task_data['task_id'], "result": result}
    }

    response['sig'] = sign_message(response)
    return jsonify(response)

@app.route('/capabilities')
def get_capabilities():
    return jsonify({
        "capabilities": [{
            "id": "text-processing",
            "input": {"text": "string"},
            "output": {"result": "string"}
        }]
    })

if __name__ == '__main__':
    app.run(port=3000)
```

### Go

**Dependencies**: Standard library only

```go
package main

import (
    "crypto/ed25519"
    "crypto/rand"
    "encoding/hex"
    "encoding/json"
    "fmt"
    "net/http"
)

type Agent struct {
    ID         string
    PrivateKey ed25519.PrivateKey
    PublicKey  ed25519.PublicKey
}

func (a *Agent) signMessage(message map[string]interface{}) string {
    data, _ := json.Marshal(message)
    signature := ed25519.Sign(a.PrivateKey, data)
    return hex.EncodeToString(signature)
}

func (a *Agent) handleTasks(w http.ResponseWriter, r *http.Request) {
    var req map[string]interface{}
    json.NewDecoder(r.Body).Decode(&req)

    data := req["data"].(map[string]interface{})
    text := data["text"].(string)

    result := map[string]interface{}{
        "result": strings.ToUpper(text),
    }

    response := map[string]interface{}{
        "from": a.ID,
        "to":   req["from"],
        "type": "task_result",
        "data": map[string]interface{}{
            "task_id": data["task_id"],
            "result":  result,
        },
    }

    response["sig"] = a.signMessage(response)
    json.NewEncoder(w).Encode(response)
}

func main() {
    // Generate identity
    publicKey, privateKey, _ := ed25519.GenerateKey(rand.Reader)
    agentID := fmt.Sprintf("hive:agentid:%s", hex.EncodeToString(rand.Read(8)))

    agent := &Agent{ID: agentID, PrivateKey: privateKey, PublicKey: publicKey}

    http.HandleFunc("/tasks", agent.handleTasks)
    http.ListenAndServe(":3000", nil)
}
```

## Implementation Tiers

<Cards>
  <Card
    title="ðŸŸ¢ Tier 1: Minimal (30 minutes)"
    description="HTTP endpoints, basic tasks, Ed25519 signatures"
    href="/docs/protocol/implementation/tiers#tier-1-minimal"
  />
  <Card
    title="ðŸŸ¡ Tier 2: Standard (1-2 weeks)"
    description="+ WebSockets, task agreements, multiple discovery"
    href="/docs/protocol/implementation/tiers#tier-2-standard"
  />
  <Card
    title="ðŸ”´ Tier 3: Full (4-6 weeks)"
    description="+ Advanced security, formal contracts, federation"
    href="/docs/protocol/implementation/tiers#tier-3-full"
  />
</Cards>

## Getting Started

**Choose your approach**:

1. **ðŸš€ Quick Start**: [30-minute implementation guide](/docs/protocol/implementation/quick-start)
2. **ðŸ“‹ Implementation Tiers**: [Choose your complexity level](/docs/protocol/implementation/tiers)
3. **ðŸ’» Example Code**: [Complete working agent](/docs/protocol/implementation/example-agent)
4. **ðŸ§ª Testing**: [Verify your implementation](/docs/protocol/implementation/testing)


<Callout type="info">
  **Language Agnostic**: H.I.V.E. works with any language that supports HTTP and
  Ed25519 cryptography. The examples above show how simple it is to implement in
  different environments.
</Callout>

---
title: Implementation Tiers
description: Choose your complexity level - Minimal, Standard, or Full
icon: Layers
---

import { Callout } from "fumadocs-ui/components/callout";
import { Cards, Card } from "fumadocs-ui/components/card";

The H.I.V.E. Protocol offers three implementation tiers to match your needs and timeline. Choose the right complexity level for your project - you can always upgrade later.

## Why Implementation Tiers?

**The Problem**: Traditional protocols are "all or nothing" - you need to implement everything to be compliant.

**The H.I.V.E. Solution**: Start simple, upgrade as needed. Most use cases only need basic features.

## Implementation Tiers Overview

<Cards>
  <Card
    title="ğŸŸ¢ Tier 1: Minimal"
    description="Perfect for most use cases. Quick implementation."
    href="#tier-1-minimal"
  />
  <Card
    title="ğŸŸ¡ Tier 2: Standard"
    description="Production-ready with enhanced features. 1-2 weeks."
    href="#tier-2-standard"
  />
  <Card
    title="ğŸ”´ Tier 3: Full"
    description="Enterprise-grade with all features. 4-6 weeks."
    href="#tier-3-full"
  />
</Cards>

---

## ğŸŸ¢ Tier 1: Minimal

**Perfect for**: MVP development, rapid prototyping, learning the protocol, most real-world use cases

### What's Included

**Core Features**:

- âœ… Simple message format (5 fields only)
- âœ… Basic HTTP endpoints (`POST /tasks`, `GET /capabilities`, `GET /status`)
- âœ… Ed25519 signatures for security
- âœ… 7 essential message types
- âœ… Simple task processing (no contracts)
- âœ… Registry-based discovery

**Message Types**:

1. `task_request` - Request a task
2. `task_response` - Accept/reject task
3. `task_result` - Deliver results
4. `task_error` - Report errors
5. `capability_query` - Request capabilities
6. `capability_response` - Advertise capabilities
7. `task_update` - Progress updates


**Code Example**:

```typescript
// Minimal H.I.V.E. agent
app.post("/tasks", (req, res) => {
  const { from, to, type, data, sig } = req.body;

  if (type === "task_request") {
    const result = processTask(data.capability, data);
    res.json({
      from: AGENT_ID,
      to: from,
      type: "task_result",
      data: { task_id: data.task_id, result },
      sig: signMessage({ result }),
    });
  }
});
```

### Benefits

- **âš¡ Fast**: Quick agent implementation
- **ğŸ› Easy to debug**: Simple message structure
- **ğŸ“ˆ Scalable**: Designed for concurrent operations
- **ğŸ”§ Maintainable**: Minimal code surface area
- **ğŸ’° Cost-effective**: Lower bandwidth and processing overhead

### Limitations

- No real-time updates (HTTP only)
- No formal contracts (just task tracking)
- Basic error handling
- Registry-based discovery only
- No advanced security features

---

## ğŸŸ¡ Tier 2: Standard

**Perfect for**: Production systems, enhanced reliability, real-time requirements

### What's Added to Tier 1

**Enhanced Features**:

- âœ… WebSocket support for real-time updates
- âœ… Basic task agreements (lightweight contracts)
- âœ… Enhanced error handling with detailed codes
- âœ… Multiple discovery methods (registry + direct + mDNS)
- âœ… Connection pooling and keep-alive
- âœ… Message compression for large payloads
- âœ… Heartbeat and health monitoring

**Additional Message Types**: 8. `heartbeat` - Agent availability signals 9. `auth_challenge` - Enhanced authentication 10. `task_agreement` - Lightweight contracts


**Code Example**:

```typescript
// WebSocket support for real-time updates
const wss = new WebSocket.Server({ port: 3001 });

wss.on("connection", (ws) => {
  ws.on("message", (data) => {
    const message = JSON.parse(data);
    if (message.type === "task_request") {
      // Process and send real-time updates
      ws.send(
        JSON.stringify({
          type: "task_update",
          data: { progress: 0.5 },
        })
      );
    }
  });
});
```

### Benefits

- **ğŸ”„ Real-time**: WebSocket support for live updates
- **ğŸ“‹ Contracts**: Basic agreements for accountability
- **ğŸ” Discovery**: Multiple discovery methods with fallbacks
- **âš¡ Performance**: Connection pooling and compression
- **ğŸ“Š Monitoring**: Health checks and heartbeat signals

### Use Cases

- Production applications requiring real-time updates
- Systems needing basic contract accountability
- High-throughput scenarios benefiting from connection pooling
- Applications requiring multiple discovery methods

---

## ğŸ”´ Tier 3: Full

**Perfect for**: Enterprise systems, maximum compatibility, complex requirements

### What's Added to Tier 2

**Enterprise Features**:

- âœ… Complete protocol implementation
- âœ… Advanced security features (mTLS, JWT, etc.)
- âœ… Federation support for multi-registry scenarios
- âœ… Full contract negotiation and enforcement
- âœ… Advanced authentication and authorization
- âœ… Comprehensive audit logging
- âœ… Custom protocol extensions
- âœ… Full backward compatibility

**All Message Types**: 11. `contract_proposal` - Formal contract negotiation 12. `contract_acceptance` - Contract agreement 13. `contract_termination` - Contract cancellation 14. `auth_token` - Advanced authentication tokens 15. `federation_query` - Cross-registry discovery


**Code Example**:

```typescript
// Full contract negotiation
class ContractManager {
  async negotiateContract(proposal) {
    // Validate proposal terms
    const validation = await this.validateProposal(proposal);

    if (validation.requiresNegotiation) {
      return this.createCounterProposal(proposal, validation.suggestions);
    }

    // Create formal contract with signatures
    const contract = await this.createFormalContract(proposal);
    return this.signContract(contract);
  }
}
```

### Benefits

- **ğŸ¢ Enterprise-ready**: Full feature set for complex organizations
- **ğŸ” Maximum security**: Advanced authentication and encryption
- **ğŸŒ Federation**: Cross-registry discovery and collaboration
- **ğŸ“œ Full contracts**: Complete negotiation and enforcement
- **ğŸ” Compliance**: Comprehensive audit trails and logging
- **ğŸ”§ Extensible**: Support for custom protocol extensions

### Use Cases

- Large enterprise deployments
- Highly regulated industries requiring audit trails
- Complex multi-organization collaborations
- Systems requiring maximum compatibility
- Applications needing custom protocol extensions

---

## Migration Path

### Tier 1 â†’ Tier 2

**What changes**:

- Add WebSocket endpoints alongside HTTP
- Implement basic task agreements
- Enhance error handling
- Add discovery fallbacks

**Migration effort**: 1-2 weeks
**Backward compatibility**: 100% - Tier 1 clients still work

### Tier 2 â†’ Tier 3

**What changes**:

- Add formal contract system
- Implement advanced security
- Add federation support
- Enhance monitoring

**Migration effort**: 2-4 weeks
**Backward compatibility**: 100% - All previous tiers work

### Gradual Upgrade Strategy

You don't have to upgrade everything at once:

1. **Start with Tier 1** - Get basic functionality working
2. **Add specific Tier 2 features** as needed (e.g., just WebSockets)
3. **Upgrade to full tiers** when requirements demand it

---

## Choosing Your Tier

### Choose Tier 1 if:

- âœ… You're building an MVP or prototype
- âœ… You need to get started quickly
- âœ… Your use case is straightforward task processing
- âœ… You want minimal complexity and overhead
- âœ… You're learning the H.I.V.E. Protocol

### Choose Tier 2 if:

- âœ… You need real-time updates
- âœ… You want basic contract accountability
- âœ… You're building a production system
- âœ… You need enhanced discovery methods
- âœ… Performance optimization is important

### Choose Tier 3 if:

- âœ… You're building enterprise systems
- âœ… You need maximum security and compliance
- âœ… You require federation across organizations
- âœ… You need custom protocol extensions
- âœ… Full backward compatibility is critical

## Implementation Resources

### Tier 1 Resources

- [Quick Start Guide](/docs/protocol/implementation/quick-start) - 30-minute implementation
- [Message Format Reference](/docs/protocol/structure/message-formats)
- [Simple Agent Example](/docs/protocol/implementation/example-agent)

### Tier 2 Resources

- [WebSocket Implementation Guide](/docs/protocol/structure/communication)
- [Task Agreement Specification](/docs/protocol/structure/agreements)
- [Discovery Methods](/docs/protocol/structure/discovery-flow)

### Tier 3 Resources

- [Complete Protocol Specification](/docs/protocol/specification)
- [Security Considerations](/docs/protocol/structure/security)
- [Federation Guide](/docs/protocol/structure/discovery-flow)

<Callout type="info">
  **Recommendation**: Start with Tier 1 for all projects. You can always upgrade
  specific features as your requirements evolve. Most successful H.I.V.E.
  deployments never need to go beyond Tier 2.
</Callout>

<Callout type="warning">
  **Important**: Higher tiers add complexity. Only upgrade when you have
  specific requirements that justify the additional implementation effort.
</Callout>

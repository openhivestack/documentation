---
title: Testing
description: Simple testing for streamlined protocols
icon: TestTube
---

import { Callout } from "fumadocs-ui/components/callout";

Testing H.I.V.E. Protocol implementations is straightforward thanks to the simplified architecture. This guide shows how to test your Tier 1 agent implementation quickly and effectively.

## Essential Testing (Tier 1)

**5 basic tests cover 90% of scenarios**:

1. **Message Format** - Verify 5-field structure
2. **Signatures** - Test Ed25519 signing/verification
3. **Capabilities** - Test each capability works
4. **Error Handling** - Verify proper error responses
5. **Discovery** - Test capability advertisement

## Simple Test Suite

```javascript
const crypto = require("crypto");

const AGENT_ENDPOINT = "http://localhost:3000";
const { privateKey: testPrivateKey } = crypto.generateKeyPairSync("ed25519", {
  privateKeyEncoding: { type: "pkcs8", format: "pem" },
});
const TEST_CLIENT_ID = "hive:agentid:test-client";

function signMessage(message) {
  return crypto
    .sign("sha256", Buffer.from(JSON.stringify(message)), testPrivateKey)
    .toString("base64");
}

// Test 1: Message Format
async function testMessageFormat() {
  console.log("ğŸ§ª Testing message format...");

  const validMessage = {
    from: TEST_CLIENT_ID,
    to: "hive:agentid:agent",
    type: "task_request",
    data: {
      task_id: "test-1",
      capability: "text-processing",
      text: "test",
      operation: "uppercase",
    },
  };

  const response = await fetch(`${AGENT_ENDPOINT}/tasks`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ ...validMessage, sig: signMessage(validMessage) }),
  });

  const result = await response.json();
  const isValid =
    result.from && result.to && result.type && result.data && result.sig;
  console.log(
    isValid ? "âœ… Message format valid" : "âŒ Message format invalid"
  );
  return isValid;
}

// Test 2: Capabilities
async function testCapabilities() {
  console.log("ğŸ§ª Testing capabilities...");

  const tests = [
    {
      capability: "text-processing",
      data: { text: "hello", operation: "uppercase" },
      expected: "HELLO",
    },
  ];

  for (const test of tests) {
    const taskRequest = {
      from: TEST_CLIENT_ID,
      to: "hive:agentid:agent",
      type: "task_request",
      data: {
        task_id: `test-${Date.now()}`,
        capability: test.capability,
        ...test.data,
      },
    };

    const response = await fetch(`${AGENT_ENDPOINT}/tasks`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ ...taskRequest, sig: signMessage(taskRequest) }),
    });

    const result = await response.json();
    const success = result.data.result.result === test.expected;
    console.log(
      success ? `âœ… ${test.capability} works` : `âŒ ${test.capability} failed`
    );
  }
}

// Test 3: Error Handling
async function testErrorHandling() {
  console.log("ğŸ§ª Testing error handling...");

  const invalidRequest = {
    from: TEST_CLIENT_ID,
    to: "hive:agentid:agent",
    type: "task_request",
    data: { task_id: "error-test", capability: "nonexistent", text: "test" },
  };

  const response = await fetch(`${AGENT_ENDPOINT}/tasks`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      ...invalidRequest,
      sig: signMessage(invalidRequest),
    }),
  });

  const result = await response.json();
  const isErrorResponse = result.type === "task_error";
  console.log(
    isErrorResponse ? "âœ… Error handling works" : "âŒ Error handling failed"
  );
}

// Test 4: Discovery
async function testDiscovery() {
  console.log("ğŸ§ª Testing discovery...");

  const response = await fetch(`${AGENT_ENDPOINT}/capabilities`);
  const result = await response.json();

  const hasCapabilities = result.capabilities && result.capabilities.length > 0;
  console.log(hasCapabilities ? "âœ… Discovery works" : "âŒ Discovery failed");
}

// Run all tests
async function runTests() {
  console.log("ğŸš€ H.I.V.E. Agent Test Suite\\n");

  await testMessageFormat();
  await testCapabilities();
  await testErrorHandling();
  await testDiscovery();

  console.log("\\nğŸ‰ Testing complete!");
}

runTests();
```

## Manual Testing

**Quick manual tests with curl**:

```bash
# Test status
curl http://localhost:3000/status

# Test capabilities
curl http://localhost:3000/capabilities

# Test invalid request (will fail due to missing signature)
curl -X POST http://localhost:3000/tasks \\
  -H "Content-Type: application/json" \\
  -d '{"from":"test","type":"task_request","data":{"capability":"invalid"}}'
```

## Production Testing Checklist

**Tier 1 Requirements**:

- [ ] All 5 basic tests pass
- [ ] Manual curl tests work
- [ ] Agent starts without errors
- [ ] Capabilities are correctly advertised
- [ ] Error responses are properly formatted

**Production Readiness**:

- [ ] HTTPS works correctly
- [ ] Private keys are loaded from environment
- [ ] Input validation prevents crashes
- [ ] Rate limiting is functional
- [ ] Logging captures important events

## Automated Testing

**package.json setup**:

```json
{
  "scripts": {
    "start": "node agent.js",
    "test": "node test-suite.js",
    "test:watch": "nodemon test-suite.js"
  },
  "devDependencies": {
    "nodemon": "^3.0.0"
  }
}
```

**CI/CD integration**:

```bash
#!/bin/bash
# test.sh
npm start &
AGENT_PID=$!
sleep 2
npm test
TEST_RESULT=$?
kill $AGENT_PID
exit $TEST_RESULT
```

<Callout type="info">
  **Testing Benefits**: The simplified protocol makes testing much easier. You
  can verify full compliance with just 5 basic tests.
</Callout>

<Callout type="warning">
  **Security Testing**: Always test with invalid signatures and malformed
  messages to ensure proper security handling.
</Callout>
